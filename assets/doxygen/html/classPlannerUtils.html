<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Bench-MR: PlannerUtils Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Bench-MR
   </div>
   <div id="projectbrief">A Motion Planning Benchmark for Wheeled Mobile Robots</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classPlannerUtils-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">PlannerUtils Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Helper for common operations during planning and evaluation.  
 <a href="classPlannerUtils.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="PlannerUtils_8hpp_source.html">PlannerUtils.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2a5cb4d6d66750979ef72f2bb6b5b64f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPlannerUtils.html#a2a5cb4d6d66750979ef72f2bb6b5b64f">PlannerUtils</a> ()=delete</td></tr>
<tr class="separator:a2a5cb4d6d66750979ef72f2bb6b5b64f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ad13afa3bb1f1c8b5ec110ca1e196c042"><td class="memTemplParams" colspan="2">template&lt;typename N &gt; </td></tr>
<tr class="memitem:ad13afa3bb1f1c8b5ec110ca1e196c042"><td class="memTemplItemLeft" align="right" valign="top">static double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classPlannerUtils.html#ad13afa3bb1f1c8b5ec110ca1e196c042">slope</a> (const N &amp;x1, const N &amp;y1, const N &amp;x2, const N &amp;y2)</td></tr>
<tr class="memdesc:ad13afa3bb1f1c8b5ec110ca1e196c042"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the angular slope between two points.  <a href="classPlannerUtils.html#ad13afa3bb1f1c8b5ec110ca1e196c042">More...</a><br /></td></tr>
<tr class="separator:ad13afa3bb1f1c8b5ec110ca1e196c042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f39f68683fa1d7c4ce8af7b975af798"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPlannerUtils.html#a0f39f68683fa1d7c4ce8af7b975af798">slope</a> (const <a class="el" href="structPoint.html">Point</a> &amp;a, const <a class="el" href="structPoint.html">Point</a> &amp;b)</td></tr>
<tr class="memdesc:a0f39f68683fa1d7c4ce8af7b975af798"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="classPlannerUtils.html#a0f39f68683fa1d7c4ce8af7b975af798">More...</a><br /></td></tr>
<tr class="separator:a0f39f68683fa1d7c4ce8af7b975af798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12dbfcb3491d9bc7c1ac9fcb91fc573d"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPlannerUtils.html#a12dbfcb3491d9bc7c1ac9fcb91fc573d">slope</a> (const <a class="el" href="Primitives_8h.html#a8cae3a66628d04c6da1644467d232a2c">ompl::base::State</a> *a, const <a class="el" href="Primitives_8h.html#a8cae3a66628d04c6da1644467d232a2c">ompl::base::State</a> *b)</td></tr>
<tr class="memdesc:a12dbfcb3491d9bc7c1ac9fcb91fc573d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="classPlannerUtils.html#a12dbfcb3491d9bc7c1ac9fcb91fc573d">More...</a><br /></td></tr>
<tr class="separator:a12dbfcb3491d9bc7c1ac9fcb91fc573d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6309eb484cd73ab49134e297435be01e"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPlannerUtils.html#a6309eb484cd73ab49134e297435be01e">equals</a> (const <a class="el" href="Primitives_8h.html#a8cae3a66628d04c6da1644467d232a2c">ompl::base::State</a> *a, const <a class="el" href="Primitives_8h.html#a8cae3a66628d04c6da1644467d232a2c">ompl::base::State</a> *b)</td></tr>
<tr class="memdesc:a6309eb484cd73ab49134e297435be01e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether two states are equal (up to some tolerance).  <a href="classPlannerUtils.html#a6309eb484cd73ab49134e297435be01e">More...</a><br /></td></tr>
<tr class="separator:a6309eb484cd73ab49134e297435be01e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad177135b1ade510284edd6773d084a70"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; <a class="el" href="structPoint.html">Point</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPlannerUtils.html#ad177135b1ade510284edd6773d084a70">toSteeredPoints</a> (const <a class="el" href="Primitives_8h.html#a8cae3a66628d04c6da1644467d232a2c">ob::State</a> *a, const <a class="el" href="Primitives_8h.html#a8cae3a66628d04c6da1644467d232a2c">ob::State</a> *b)</td></tr>
<tr class="separator:ad177135b1ade510284edd6773d084a70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dd44d53d9e17efd9ed12f0ec1246b61"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPlannerUtils.html#a6dd44d53d9e17efd9ed12f0ec1246b61">collides</a> (const std::vector&lt; <a class="el" href="structPoint.html">Point</a> &gt; &amp;path)</td></tr>
<tr class="memdesc:a6dd44d53d9e17efd9ed12f0ec1246b61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether points on a path collide with the environment.  <a href="classPlannerUtils.html#a6dd44d53d9e17efd9ed12f0ec1246b61">More...</a><br /></td></tr>
<tr class="separator:a6dd44d53d9e17efd9ed12f0ec1246b61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a650bcc400db1589f3d4a9b37cd745e4e"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPlannerUtils.html#a650bcc400db1589f3d4a9b37cd745e4e">collides</a> (const ompl::geometric::PathGeometric &amp;path)</td></tr>
<tr class="memdesc:a650bcc400db1589f3d4a9b37cd745e4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collision check that respects the collision model.  <a href="classPlannerUtils.html#a650bcc400db1589f3d4a9b37cd745e4e">More...</a><br /></td></tr>
<tr class="separator:a650bcc400db1589f3d4a9b37cd745e4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab893827269748e139b168df93fda4ab6"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPlannerUtils.html#ab893827269748e139b168df93fda4ab6">collides</a> (const <a class="el" href="Primitives_8h.html#a8cae3a66628d04c6da1644467d232a2c">ompl::base::State</a> *a, const <a class="el" href="Primitives_8h.html#a8cae3a66628d04c6da1644467d232a2c">ompl::base::State</a> *b)</td></tr>
<tr class="memdesc:ab893827269748e139b168df93fda4ab6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collision check of segment between two states.  <a href="classPlannerUtils.html#ab893827269748e139b168df93fda4ab6">More...</a><br /></td></tr>
<tr class="separator:ab893827269748e139b168df93fda4ab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a589d092db32fb2f3861210540b2b5bdc"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPlannerUtils.html#a589d092db32fb2f3861210540b2b5bdc">collides</a> (const <a class="el" href="Primitives_8h.html#a8cae3a66628d04c6da1644467d232a2c">ompl::base::State</a> *a, const <a class="el" href="Primitives_8h.html#a8cae3a66628d04c6da1644467d232a2c">ompl::base::State</a> *b, og::PathGeometric &amp;path)</td></tr>
<tr class="memdesc:a589d092db32fb2f3861210540b2b5bdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collision check that respects the collision model.  <a href="classPlannerUtils.html#a589d092db32fb2f3861210540b2b5bdc">More...</a><br /></td></tr>
<tr class="separator:a589d092db32fb2f3861210540b2b5bdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a040d6146a3b11286a49bf7192b8cba88"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPlannerUtils.html#a040d6146a3b11286a49bf7192b8cba88">collides</a> (const std::vector&lt; <a class="el" href="structPoint.html">Point</a> &gt; &amp;path, std::vector&lt; <a class="el" href="structPoint.html">Point</a> &gt; &amp;collisions)</td></tr>
<tr class="memdesc:a040d6146a3b11286a49bf7192b8cba88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether points on a path collide with the environment.  <a href="classPlannerUtils.html#a040d6146a3b11286a49bf7192b8cba88">More...</a><br /></td></tr>
<tr class="separator:a040d6146a3b11286a49bf7192b8cba88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8022a74e4794cfdb61362ba161e2b025"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPlannerUtils.html#a8022a74e4794cfdb61362ba161e2b025">collides</a> (const <a class="el" href="Primitives_8h.html#a8cae3a66628d04c6da1644467d232a2c">ompl::base::State</a> *a, const <a class="el" href="Primitives_8h.html#a8cae3a66628d04c6da1644467d232a2c">ompl::base::State</a> *b, std::vector&lt; <a class="el" href="structPoint.html">Point</a> &gt; &amp;collisions)</td></tr>
<tr class="memdesc:a8022a74e4794cfdb61362ba161e2b025"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collision check of segment between two states.  <a href="classPlannerUtils.html#a8022a74e4794cfdb61362ba161e2b025">More...</a><br /></td></tr>
<tr class="separator:a8022a74e4794cfdb61362ba161e2b025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a573a41be07b340ebc562a853d89b336e"><td class="memItemLeft" align="right" valign="top">static ompl::geometric::PathGeometric&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPlannerUtils.html#a573a41be07b340ebc562a853d89b336e">interpolated</a> (ompl::geometric::PathGeometric path)</td></tr>
<tr class="memdesc:a573a41be07b340ebc562a853d89b336e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate path based on its associated state space.  <a href="classPlannerUtils.html#a573a41be07b340ebc562a853d89b336e">More...</a><br /></td></tr>
<tr class="separator:a573a41be07b340ebc562a853d89b336e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73d6abf2e3379ad443ed5dd42aed6021"><td class="memItemLeft" align="right" valign="top">static ompl::control::PathControl&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPlannerUtils.html#a73d6abf2e3379ad443ed5dd42aed6021">interpolated</a> (ompl::control::PathControl path)</td></tr>
<tr class="memdesc:a73d6abf2e3379ad443ed5dd42aed6021"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="classPlannerUtils.html#a73d6abf2e3379ad443ed5dd42aed6021">More...</a><br /></td></tr>
<tr class="separator:a73d6abf2e3379ad443ed5dd42aed6021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65540d3d07d552eef0f6f5b5ed1ddbaa"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPlannerUtils.html#a65540d3d07d552eef0f6f5b5ed1ddbaa">updateAngles</a> (ompl::geometric::PathGeometric &amp;path, bool AverageAngles=true, bool preventCollisions=true)</td></tr>
<tr class="separator:a65540d3d07d552eef0f6f5b5ed1ddbaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf8782dd36b5bb77294f3ab5c51d5b14"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPlannerUtils.html#adf8782dd36b5bb77294f3ab5c51d5b14">gradientDescent</a> (ompl::geometric::PathGeometric &amp;path, unsigned int rounds, double eta, double discount=1.)</td></tr>
<tr class="separator:adf8782dd36b5bb77294f3ab5c51d5b14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d5e3242e6fad43d0954043a274ed51a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPlannerUtils.html#a5d5e3242e6fad43d0954043a274ed51a">gradientDescent</a> (std::vector&lt; <a class="el" href="structPoint.html">Point</a> &gt; &amp;path, unsigned int rounds, double eta, double discount=1.)</td></tr>
<tr class="separator:a5d5e3242e6fad43d0954043a274ed51a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07ce230e827f35d5c387e0d4f77f96b4"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; <a class="el" href="structPoint.html">Point</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPlannerUtils.html#a07ce230e827f35d5c387e0d4f77f96b4">linearInterpolate</a> (const <a class="el" href="structPoint.html">Point</a> &amp;a, const <a class="el" href="structPoint.html">Point</a> &amp;b, double dt=0.1)</td></tr>
<tr class="memdesc:a07ce230e827f35d5c387e0d4f77f96b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linearly interpolate between two points.  <a href="classPlannerUtils.html#a07ce230e827f35d5c387e0d4f77f96b4">More...</a><br /></td></tr>
<tr class="separator:a07ce230e827f35d5c387e0d4f77f96b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a896bf9e02e17491b18dafbfaf2ac36a9"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; <a class="el" href="structPoint.html">Point</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPlannerUtils.html#a896bf9e02e17491b18dafbfaf2ac36a9">linearInterpolate</a> (<a class="el" href="Primitives_8h.html#a8cae3a66628d04c6da1644467d232a2c">ompl::base::State</a> *a, <a class="el" href="Primitives_8h.html#a8cae3a66628d04c6da1644467d232a2c">ompl::base::State</a> *b, double dt=0.1)</td></tr>
<tr class="memdesc:a896bf9e02e17491b18dafbfaf2ac36a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.This does not take into account yaw and returns a list of xy points.  <a href="classPlannerUtils.html#a896bf9e02e17491b18dafbfaf2ac36a9">More...</a><br /></td></tr>
<tr class="separator:a896bf9e02e17491b18dafbfaf2ac36a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad612b78cfa5a157d4e320fedceac8e8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="Primitives_8h.html#a8cae3a66628d04c6da1644467d232a2c">ompl::base::State</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPlannerUtils.html#aad612b78cfa5a157d4e320fedceac8e8">closestPoint</a> (<a class="el" href="structPoint.html">Point</a> x, const std::vector&lt; <a class="el" href="structPoint.html">Point</a> &gt; &amp;points)</td></tr>
<tr class="memdesc:aad612b78cfa5a157d4e320fedceac8e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find closest collision-free point in an ordered set of points.  <a href="classPlannerUtils.html#aad612b78cfa5a157d4e320fedceac8e8">More...</a><br /></td></tr>
<tr class="separator:aad612b78cfa5a157d4e320fedceac8e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62d0c3b9b40329d478de76aca774ccd6"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPlannerUtils.html#a62d0c3b9b40329d478de76aca774ccd6">totalLength</a> (const std::vector&lt; <a class="el" href="structPoint.html">Point</a> &gt; &amp;path)</td></tr>
<tr class="memdesc:a62d0c3b9b40329d478de76aca774ccd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute total length of a path.  <a href="classPlannerUtils.html#a62d0c3b9b40329d478de76aca774ccd6">More...</a><br /></td></tr>
<tr class="separator:a62d0c3b9b40329d478de76aca774ccd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa788b77a35c074e42b03e3245b156337"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; <a class="el" href="structPoint.html">Point</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPlannerUtils.html#aa788b77a35c074e42b03e3245b156337">equidistantSampling</a> (const std::vector&lt; <a class="el" href="structPoint.html">Point</a> &gt; &amp;path, size_t targetSize)</td></tr>
<tr class="memdesc:aa788b77a35c074e42b03e3245b156337"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute equidistance samples along path.  <a href="classPlannerUtils.html#aa788b77a35c074e42b03e3245b156337">More...</a><br /></td></tr>
<tr class="separator:aa788b77a35c074e42b03e3245b156337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e49a56a5e82ef2a006689886c315d79"><td class="memTemplParams" colspan="2">template&lt;typename N &gt; </td></tr>
<tr class="memitem:a3e49a56a5e82ef2a006689886c315d79"><td class="memTemplItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classPlannerUtils.html#a3e49a56a5e82ef2a006689886c315d79">num2str</a> (const N &amp;v, unsigned int precision=3)</td></tr>
<tr class="memdesc:a3e49a56a5e82ef2a006689886c315d79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a number to a string with the given precision.  <a href="classPlannerUtils.html#a3e49a56a5e82ef2a006689886c315d79">More...</a><br /></td></tr>
<tr class="separator:a3e49a56a5e82ef2a006689886c315d79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af37e2dabc6e20c7e3f876b40b34d6ead"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPlannerUtils.html#af37e2dabc6e20c7e3f876b40b34d6ead">normalizeAngle</a> (double angle)</td></tr>
<tr class="memdesc:af37e2dabc6e20c7e3f876b40b34d6ead"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalize angle in radians to the interval \((-\pi, \pi]\).  <a href="classPlannerUtils.html#af37e2dabc6e20c7e3f876b40b34d6ead">More...</a><br /></td></tr>
<tr class="separator:af37e2dabc6e20c7e3f876b40b34d6ead"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Helper for common operations during planning and evaluation. </p>
<p >Contains static functions for collision checking, and other path evaluations. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a2a5cb4d6d66750979ef72f2bb6b5b64f" name="a2a5cb4d6d66750979ef72f2bb6b5b64f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a5cb4d6d66750979ef72f2bb6b5b64f">&#9670;&nbsp;</a></span>PlannerUtils()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PlannerUtils::PlannerUtils </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aad612b78cfa5a157d4e320fedceac8e8" name="aad612b78cfa5a157d4e320fedceac8e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad612b78cfa5a157d4e320fedceac8e8">&#9670;&nbsp;</a></span>closestPoint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="Primitives_8h.html#a8cae3a66628d04c6da1644467d232a2c">ompl::base::State</a> * PlannerUtils::closestPoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPoint.html">Point</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structPoint.html">Point</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find closest collision-free point in an ordered set of points. </p>
<p >The closest point will be converted to a state, whose yaw is computed based on neighboring points.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The reference point. </td></tr>
    <tr><td class="paramname">points</td><td>The collection of points to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The state closest to <code>x</code>. </dd></dl>

</div>
</div>
<a id="ab893827269748e139b168df93fda4ab6" name="ab893827269748e139b168df93fda4ab6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab893827269748e139b168df93fda4ab6">&#9670;&nbsp;</a></span>collides() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool PlannerUtils::collides </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="Primitives_8h.html#a8cae3a66628d04c6da1644467d232a2c">ompl::base::State</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="Primitives_8h.html#a8cae3a66628d04c6da1644467d232a2c">ompl::base::State</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Collision check of segment between two states. </p>
<p >The collision model is set in <a class="el" href="structPlannerSettings_1_1GlobalSettings_1_1EnvironmentSettings_1_1CollisionSettings.html#ab46aba4cc895285670877f68c18c1550" title="Which model is used for collision checking.">PlannerSettings::GlobalSettings::EnvironmentSettings::CollisionSettings::collision_model</a>. The environment is set through <a class="el" href="structPlannerSettings_1_1GlobalSettings.html#a12a983f31c97d8b54682df1033312cf9" title="Environment used for planning.">PlannerSettings::GlobalSettings::environment</a>. The steering function used to compute the path between the two state is defined by <a class="el" href="structPlannerSettings_1_1GlobalSettings_1_1OmplSettings.html#ad9f0b77e7b7cc8ffb12caa27975e0257">PlannerSettings::GlobalSettings::OmplSettings::state_space</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first state of the path segment to check. </td></tr>
    <tr><td class="paramname">b</td><td>The last state of the path segment to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the segment collides with the environment, otherwise false. </dd></dl>

</div>
</div>
<a id="a589d092db32fb2f3861210540b2b5bdc" name="a589d092db32fb2f3861210540b2b5bdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a589d092db32fb2f3861210540b2b5bdc">&#9670;&nbsp;</a></span>collides() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool PlannerUtils::collides </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="Primitives_8h.html#a8cae3a66628d04c6da1644467d232a2c">ompl::base::State</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="Primitives_8h.html#a8cae3a66628d04c6da1644467d232a2c">ompl::base::State</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">og::PathGeometric &amp;&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Collision check that respects the collision model. </p>
<p >The path is interpolated prior to collision checking.</p>
<p >The collision model is set in <a class="el" href="structPlannerSettings_1_1GlobalSettings_1_1EnvironmentSettings_1_1CollisionSettings.html#ab46aba4cc895285670877f68c18c1550" title="Which model is used for collision checking.">PlannerSettings::GlobalSettings::EnvironmentSettings::CollisionSettings::collision_model</a>. The environment is set through <a class="el" href="structPlannerSettings_1_1GlobalSettings.html#a12a983f31c97d8b54682df1033312cf9" title="Environment used for planning.">PlannerSettings::GlobalSettings::environment</a>. Interpolation is based on the state space of the path.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Deprecated. </td></tr>
    <tr><td class="paramname">b</td><td>Deprecated. </td></tr>
    <tr><td class="paramname">The</td><td>OMPL path to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the path collides with the environment, otherwise false. </dd></dl>

</div>
</div>
<a id="a8022a74e4794cfdb61362ba161e2b025" name="a8022a74e4794cfdb61362ba161e2b025"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8022a74e4794cfdb61362ba161e2b025">&#9670;&nbsp;</a></span>collides() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool PlannerUtils::collides </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="Primitives_8h.html#a8cae3a66628d04c6da1644467d232a2c">ompl::base::State</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="Primitives_8h.html#a8cae3a66628d04c6da1644467d232a2c">ompl::base::State</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structPoint.html">Point</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>collisions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Collision check of segment between two states. </p>
<p >The collision model is set in <a class="el" href="structPlannerSettings_1_1GlobalSettings_1_1EnvironmentSettings_1_1CollisionSettings.html#ab46aba4cc895285670877f68c18c1550" title="Which model is used for collision checking.">PlannerSettings::GlobalSettings::EnvironmentSettings::CollisionSettings::collision_model</a>. The environment is set through <a class="el" href="structPlannerSettings_1_1GlobalSettings.html#a12a983f31c97d8b54682df1033312cf9" title="Environment used for planning.">PlannerSettings::GlobalSettings::environment</a>. The steering function used to compute the path between the two state is defined by <a class="el" href="structPlannerSettings_1_1GlobalSettings_1_1OmplSettings.html#ad9f0b77e7b7cc8ffb12caa27975e0257">PlannerSettings::GlobalSettings::OmplSettings::state_space</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first state of the path segment to check. </td></tr>
    <tr><td class="paramname">b</td><td>The last state of the path segment to check. </td></tr>
    <tr><td class="paramname">collisions</td><td>Points that collide with the environment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the segment collides with the environment, otherwise false. </dd></dl>

</div>
</div>
<a id="a650bcc400db1589f3d4a9b37cd745e4e" name="a650bcc400db1589f3d4a9b37cd745e4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a650bcc400db1589f3d4a9b37cd745e4e">&#9670;&nbsp;</a></span>collides() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool PlannerUtils::collides </td>
          <td>(</td>
          <td class="paramtype">const ompl::geometric::PathGeometric &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Collision check that respects the collision model. </p>
<p >No additional interpolation along the path is performed prior to collision checking.</p>
<p >The collision model is set in <a class="el" href="structPlannerSettings_1_1GlobalSettings_1_1EnvironmentSettings_1_1CollisionSettings.html#ab46aba4cc895285670877f68c18c1550" title="Which model is used for collision checking.">PlannerSettings::GlobalSettings::EnvironmentSettings::CollisionSettings::collision_model</a>. The environment is set through <a class="el" href="structPlannerSettings_1_1GlobalSettings.html#a12a983f31c97d8b54682df1033312cf9" title="Environment used for planning.">PlannerSettings::GlobalSettings::environment</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">The</td><td>OMPL path to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the path collides with the environment, otherwise false. </dd></dl>

</div>
</div>
<a id="a6dd44d53d9e17efd9ed12f0ec1246b61" name="a6dd44d53d9e17efd9ed12f0ec1246b61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dd44d53d9e17efd9ed12f0ec1246b61">&#9670;&nbsp;</a></span>collides() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool PlannerUtils::collides </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structPoint.html">Point</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether points on a path collide with the environment. </p>
<p >This function does not consider the collision model, since points only contain x and y coordinates. The environment is set through <a class="el" href="structPlannerSettings_1_1GlobalSettings.html#a12a983f31c97d8b54682df1033312cf9" title="Environment used for planning.">PlannerSettings::GlobalSettings::environment</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The points on the path. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the path collides with the environment, false otherwise. </dd></dl>

</div>
</div>
<a id="a040d6146a3b11286a49bf7192b8cba88" name="a040d6146a3b11286a49bf7192b8cba88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a040d6146a3b11286a49bf7192b8cba88">&#9670;&nbsp;</a></span>collides() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool PlannerUtils::collides </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structPoint.html">Point</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structPoint.html">Point</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>collisions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether points on a path collide with the environment. </p>
<p >This function does not consider the collision model, since points only contain x and y coordinates. The environment is set through <a class="el" href="structPlannerSettings_1_1GlobalSettings.html#a12a983f31c97d8b54682df1033312cf9" title="Environment used for planning.">PlannerSettings::GlobalSettings::environment</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The points on the path. </td></tr>
    <tr><td class="paramname">collisions</td><td>Points that collide with the environment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the path collides with the environment, false otherwise. </dd></dl>

</div>
</div>
<a id="a6309eb484cd73ab49134e297435be01e" name="a6309eb484cd73ab49134e297435be01e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6309eb484cd73ab49134e297435be01e">&#9670;&nbsp;</a></span>equals()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool PlannerUtils::equals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="Primitives_8h.html#a8cae3a66628d04c6da1644467d232a2c">ompl::base::State</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="Primitives_8h.html#a8cae3a66628d04c6da1644467d232a2c">ompl::base::State</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether two states are equal (up to some tolerance). </p>
<p >Check compares x, y, and yaw difference. All have to be within tolerance for states to be considered equal. Tolerance is set in <a class="el" href="structPlannerSettings_1_1GlobalSettings_1_1OmplSettings.html#a3116cc210bef6a01e0786ea57a4d3323">PlannerSettings::GlobalSettings::OmplSettings::state_equality_tolerance</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first state. </td></tr>
    <tr><td class="paramname">b</td><td>The second state. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the states are equal, false otherwise. </dd></dl>

</div>
</div>
<a id="aa788b77a35c074e42b03e3245b156337" name="aa788b77a35c074e42b03e3245b156337"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa788b77a35c074e42b03e3245b156337">&#9670;&nbsp;</a></span>equidistantSampling()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt; <a class="el" href="structPoint.html">Point</a> &gt; PlannerUtils::equidistantSampling </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structPoint.html">Point</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>targetSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute equidistance samples along path. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The input path. </td></tr>
    <tr><td class="paramname">targetSize</td><td>The number of equdistant samples on the output path. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The path of size targetSize with equidistant samples. </dd></dl>

</div>
</div>
<a id="adf8782dd36b5bb77294f3ab5c51d5b14" name="adf8782dd36b5bb77294f3ab5c51d5b14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf8782dd36b5bb77294f3ab5c51d5b14">&#9670;&nbsp;</a></span>gradientDescent() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void PlannerUtils::gradientDescent </td>
          <td>(</td>
          <td class="paramtype">ompl::geometric::PathGeometric &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>rounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>discount</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5d5e3242e6fad43d0954043a274ed51a" name="a5d5e3242e6fad43d0954043a274ed51a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d5e3242e6fad43d0954043a274ed51a">&#9670;&nbsp;</a></span>gradientDescent() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void PlannerUtils::gradientDescent </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structPoint.html">Point</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>rounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>discount</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a73d6abf2e3379ad443ed5dd42aed6021" name="a73d6abf2e3379ad443ed5dd42aed6021"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73d6abf2e3379ad443ed5dd42aed6021">&#9670;&nbsp;</a></span>interpolated() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ompl::control::PathControl PlannerUtils::interpolated </td>
          <td>(</td>
          <td class="paramtype">ompl::control::PathControl&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">The</td><td>control path to interpolate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a573a41be07b340ebc562a853d89b336e" name="a573a41be07b340ebc562a853d89b336e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a573a41be07b340ebc562a853d89b336e">&#9670;&nbsp;</a></span>interpolated() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ompl::geometric::PathGeometric PlannerUtils::interpolated </td>
          <td>(</td>
          <td class="paramtype">ompl::geometric::PathGeometric&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interpolate path based on its associated state space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">The</td><td>geometric path to interpolate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The interpolated path. </dd></dl>

</div>
</div>
<a id="a07ce230e827f35d5c387e0d4f77f96b4" name="a07ce230e827f35d5c387e0d4f77f96b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07ce230e827f35d5c387e0d4f77f96b4">&#9670;&nbsp;</a></span>linearInterpolate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt; <a class="el" href="structPoint.html">Point</a> &gt; PlannerUtils::linearInterpolate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structPoint.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structPoint.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dt</em> = <code>0.1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Linearly interpolate between two points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first point. </td></tr>
    <tr><td class="paramname">b</td><td>The last point. </td></tr>
    <tr><td class="paramname">dt</td><td>The step to take (where \(t\) parametrizes the line, i.e., \(t\in[0,1]\)). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The points on the line from <code>a</code> to <code>b</code>, including both of these points. </dd></dl>

</div>
</div>
<a id="a896bf9e02e17491b18dafbfaf2ac36a9" name="a896bf9e02e17491b18dafbfaf2ac36a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a896bf9e02e17491b18dafbfaf2ac36a9">&#9670;&nbsp;</a></span>linearInterpolate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt; <a class="el" href="structPoint.html">Point</a> &gt; PlannerUtils::linearInterpolate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Primitives_8h.html#a8cae3a66628d04c6da1644467d232a2c">ompl::base::State</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="Primitives_8h.html#a8cae3a66628d04c6da1644467d232a2c">ompl::base::State</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dt</em> = <code>0.1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.This does not take into account yaw and returns a list of xy points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first state. </td></tr>
    <tr><td class="paramname">b</td><td>The last state. </td></tr>
    <tr><td class="paramname">dt</td><td>The step to take (where \(t\) parametrizes the line, i.e., \(t\in[0,1]\)). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The points on the line from <code>a</code> to <code>b</code>, including both of these points. </dd></dl>

</div>
</div>
<a id="af37e2dabc6e20c7e3f876b40b34d6ead" name="af37e2dabc6e20c7e3f876b40b34d6ead"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af37e2dabc6e20c7e3f876b40b34d6ead">&#9670;&nbsp;</a></span>normalizeAngle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double PlannerUtils::normalizeAngle </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>angle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Normalize angle in radians to the interval \((-\pi, \pi]\). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">angle</td><td>The angle to normalize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The normalized angle. </dd></dl>

</div>
</div>
<a id="a3e49a56a5e82ef2a006689886c315d79" name="a3e49a56a5e82ef2a006689886c315d79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e49a56a5e82ef2a006689886c315d79">&#9670;&nbsp;</a></span>num2str()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename N &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string PlannerUtils::num2str </td>
          <td>(</td>
          <td class="paramtype">const N &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>precision</em> = <code>3</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a number to a string with the given precision. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The number to convert to a string. </td></tr>
    <tr><td class="paramname">precision</td><td>The precision used when converting the number to a string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The string containing the number. </dd></dl>

</div>
</div>
<a id="ad13afa3bb1f1c8b5ec110ca1e196c042" name="ad13afa3bb1f1c8b5ec110ca1e196c042"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad13afa3bb1f1c8b5ec110ca1e196c042">&#9670;&nbsp;</a></span>slope() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename N &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double PlannerUtils::slope </td>
          <td>(</td>
          <td class="paramtype">const N &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const N &amp;&#160;</td>
          <td class="paramname"><em>y1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const N &amp;&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const N &amp;&#160;</td>
          <td class="paramname"><em>y2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the angular slope between two points. </p>
<p >The slope will be zero, for example, for a line from \((0,0)\) to \((1,0)\). The slope will be \(\frac{\pi}{2}\), for example, for a line from \((0,0)\) to \((0,1)\).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x1</td><td>X-coordinate of first point. </td></tr>
    <tr><td class="paramname">y1</td><td>Y-coordinate of first point. </td></tr>
    <tr><td class="paramname">x2</td><td>X-coorindate of second point. </td></tr>
    <tr><td class="paramname">y2</td><td>Y-coordinate of second point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Angular slope of the line in the interval \((-\pi,\pi]\) </dd></dl>

</div>
</div>
<a id="a12dbfcb3491d9bc7c1ac9fcb91fc573d" name="a12dbfcb3491d9bc7c1ac9fcb91fc573d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12dbfcb3491d9bc7c1ac9fcb91fc573d">&#9670;&nbsp;</a></span>slope() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double PlannerUtils::slope </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="Primitives_8h.html#a8cae3a66628d04c6da1644467d232a2c">ompl::base::State</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="Primitives_8h.html#a8cae3a66628d04c6da1644467d232a2c">ompl::base::State</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The state containing the first point. </td></tr>
    <tr><td class="paramname">b</td><td>The state containing the second point. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0f39f68683fa1d7c4ce8af7b975af798" name="a0f39f68683fa1d7c4ce8af7b975af798"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f39f68683fa1d7c4ce8af7b975af798">&#9670;&nbsp;</a></span>slope() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double PlannerUtils::slope </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structPoint.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structPoint.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first point. </td></tr>
    <tr><td class="paramname">b</td><td>The second point. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad177135b1ade510284edd6773d084a70" name="ad177135b1ade510284edd6773d084a70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad177135b1ade510284edd6773d084a70">&#9670;&nbsp;</a></span>toSteeredPoints()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt; <a class="el" href="structPoint.html">Point</a> &gt; PlannerUtils::toSteeredPoints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="Primitives_8h.html#a8cae3a66628d04c6da1644467d232a2c">ob::State</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="Primitives_8h.html#a8cae3a66628d04c6da1644467d232a2c">ob::State</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a62d0c3b9b40329d478de76aca774ccd6" name="a62d0c3b9b40329d478de76aca774ccd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62d0c3b9b40329d478de76aca774ccd6">&#9670;&nbsp;</a></span>totalLength()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double PlannerUtils::totalLength </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structPoint.html">Point</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute total length of a path. </p>
<p >The length between two points is calculated as Euclidean distance. The total length is computed as the sum of pairwise distances.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The ordered points along the path. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The total length of the path as the sum of pairwise Euclidean distances. </dd></dl>

</div>
</div>
<a id="a65540d3d07d552eef0f6f5b5ed1ddbaa" name="a65540d3d07d552eef0f6f5b5ed1ddbaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65540d3d07d552eef0f6f5b5ed1ddbaa">&#9670;&nbsp;</a></span>updateAngles()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void PlannerUtils::updateAngles </td>
          <td>(</td>
          <td class="paramtype">ompl::geometric::PathGeometric &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>AverageAngles</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>preventCollisions</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/utils/<a class="el" href="PlannerUtils_8hpp_source.html">PlannerUtils.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
